function quadrotor_sim
	ITERATION_TIMES = 10000

	math = se3_math;

	uav_dynamics = dynamics;        %create uav dynamics object
	uav_dynamics.dt = 0.001;        %set iteration period [sec]
	uav_dynamics.mass = 1;          %set uav mass [kg]
	uav_dynamics.a = [0; 0; 0];     %acceleration of uav [m/s^2], effected by applied force
	uav_dynamics.v = [0; 0; 0];     %initial velocity of uav [m/s]
	uav_dynamics.x = [0; 0; 0];     %initial position of uav [m]
	uav_dynamics.W = [0; 0; 0];     %initial angular velocity of uav
	uav_dynamics.W_dot = [0; 0; 0]; %angular acceleration of uav, effected by applied moment
	uav_dynamics.f = [0; 0; 0];     %force generated by controller
	uav_dynamics.M = [0; 0; 0];     %moment generated by controller
	uav_dynamics.R = math.euler_to_dcm(deg2rad(0), deg2rad(0), deg2rad(0)); %initial attitude (DCM)

	uav_dynamics.J = [0.01466 0 0;  %inertia matrix of uav
			  0 0.01466 0;
			  0 0 0.02848];

	%plot datas
	time_arr = zeros(1, ITERATION_TIMES);
	pos_a_arr = zeros(1, ITERATION_TIMES);
	pos_v_arr = zeros(1, ITERATION_TIMES);
	pos_x_arr = zeros(1, ITERATION_TIMES);
	W_dot_arr = zeros(1, ITERATION_TIMES);
	W_arr = zeros(1, ITERATION_TIMES);
	M_arr = zeros(1, ITERATION_TIMES);
	prv_angle_arr = zeros(1, ITERATION_TIMES);
	eR_arr = zeros(1, ITERATION_TIMES);
	eW_arr = zeros(1, ITERATION_TIMES);

	Wd = [0; 0; 0];
	W_dot_d = [0; 0; 0];
	kR = [5; 5; 5];
	kW = [1; 1; 1];

	for i = 1: ITERATION_TIMES
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Update System Dynamics %
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		uav_dynamics = update(uav_dynamics);

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Geometry Tracking Controller for Quadrotor %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		desired_roll = deg2rad(30);
		desired_pitch = deg2rad(10);
		desired_yaw = deg2rad(35);
		Rd = math.euler_to_dcm(desired_roll, desired_pitch, desired_yaw);

		Rt = uav_dynamics.R';

		%attitude errors
		eR = 0.5 * math.vee_map_3x3((Rd'*uav_dynamics.R - Rt*Rd));
		eW = uav_dynamics.W - Rt*Rd*Wd;

		WJW = cross(uav_dynamics.W, uav_dynamics.J * uav_dynamics.W);
		M_feedfoward = WJW - J*(math.hat_map_3x3(uav_dynamics.W)*Rt*Rd*Wd - Rt*Rd*W_dot_d);
		uav_dynamics.M(1) = -kR(1)*eR(1) - kW(1)*eW(1) + M_feedfoward(1);
		uav_dynamics.M(2) = -kR(2)*eR(2) - kW(2)*eW(2) + M_feedfoward(2);
		uav_dynamics.M(3) = -kR(3)*eR(3) - kW(3)*eW(3) + M_feedfoward(3);

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Record datas for plotting %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		eR_arr(i) = rad2deg(eR(1));
		pos_a_arr(i) = uav_dynamics.a(1);
		pos_v_arr(i) = uav_dynamics.v(1);
		pos_x_arr(i) = uav_dynamics.x(1);
		W_dot_arr(i) = rad2deg(uav_dynamics.W_dot(1));
		W_arr(i) = rad2deg(uav_dynamics.W(1));
		M_arr(i) = uav_dynamics.M(1);
		prv_angle_arr(i) = rad2deg(uav_dynamics.prv_angle);
		time_arr(i) = i * uav_dynamics.dt;
	end

	figure(1);
	plot(time_arr, eR_arr);
	disp("press any button to leave");
	pause;
end
